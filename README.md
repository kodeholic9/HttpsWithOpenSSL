Technical Specification] Native TLS Tunneling Engine: HttpsWithOpenSSL
1. 개요 (Philosophy)
본 엔진은 안드로이드 시스템 네트워크 스택의 불투명성과 제조사별 파편화된 보안 정책을 완전히 배제하고, L4(TCP)와 L7(Application) 사이의 보안 계층을 개발자가 직접 통제하기 위해 설계되었습니다.

특히, 표준 TLS 1.3에서 배제된 **국산 암호화 표준(ARIA)**을 수용하면서도, 모바일 환경의 고질적인 문제인 **'네트워크 행(Hang)으로 인한 ANR'**과 **'JNI 메모리 오염에 따른 프로세스 강제 종료'**를 원천 차단하는 것을 최우선 과제로 삼습니다.

2. 결정적 자원 관리: 64-Slot 정적 풀 아키텍처
JNI 환경에서 동적 메모리 할당(malloc/new)과 포인터의 Java 계층 노출은 시스템 불안정의 가장 큰 원인입니다. 이를 해결하기 위해 본 엔진은 '결정적 메모리 관리(Deterministic Memory Management)' 시스템을 구축했습니다.

2.1. 정적 슬롯 예비 할당 (Fixed Pool Strategy)
메모리 파편화 방지: MAX_TLS_CONN_NUM(64)개의 tlsconn_t 구조체를 전역 메모리 영역(tlsmagic_t Oz)에 미리 확보합니다. 이는 빈번한 세션 생성/소멸 과정에서 발생할 수 있는 힙 파편화를 원천 차단하며, 시스템이 사용하는 최대 메모리 점유율을 예측 가능하게 만듭니다.

Opaque Handle (Index-based Access): Java 계층에는 실제 메모리 주소(Pointer)를 절대 노출하지 않습니다. 오직 0~63 사이의 **인덱스(tlsconn_id)**만을 핸들로 사용합니다.

Validation Layer: 모든 네이티브 진입점에서 TLSCONN_CHK 매크로와 occupied 플래그를 검사합니다. 만약 Java 단에서 이미 닫힌 세션이나 잘못된 인덱스로 접근하더라도, 시스템은 SIGSEGV(크래시)를 뱉는 대신 우아하게 에러 리턴으로 대응합니다.

3. 안정적 I/O 상태 머신: 하이브리드 제어 모델
TLS 프로토콜은 핸드셰이크(제어)와 데이터 송수신(스트림)이라는 이질적인 두 단계를 가집니다. 본 엔진은 각 단계의 특성에 맞춘 최적화된 I/O 모델을 사용합니다.

3.1. Handshake Phase: 논블로킹 상태 추적
연결 초기 단계에서는 소켓을 O_NONBLOCK으로 설정하고 SSL_connect()를 수행합니다.

SSL_ERROR_WANT_READ/WRITE 상태가 발생하면 select() 루프를 통해 소켓의 준비 상태를 정교하게 추적하여, 핸드셰이크 과정에서 스레드가 무한 대기에 빠지는 현상을 방지합니다.

3.2. Data Phase: 메모리 BIO 스왑 및 커스텀 암호화 처리
핸드셰이크 완료 후, 소켓과 SSL 객체 사이에 **메모리 BIO(rbio, wbio)**를 물리적으로 배치합니다.

이는 소켓에서 읽어온 암호화 패킷을 네이티브 버퍼 레벨에서 직접 핸들링할 수 있게 하며, 특히 ARIA 패치와 같은 커스텀 사이퍼슈트가 적용된 환경에서 애플리케이션 데이터의 무결성을 100% 보장합니다.

4. 비상 중단 메커니즘: 파이프 기반 시그널 시스템
모바일 네트워크 환경은 불확실하며, 서버의 무응답(Hang)은 언제든 발생할 수 있습니다. 본 엔진은 네이티브 루프를 강제로 깨우기 위한 **'비상 탈출 장치'**를 갖추고 있습니다.

4.1. 제어용 파이프(pipefd) 운용
각 커넥션 슬롯은 자신만의 시그널 파이프(pipefd)를 가집니다.

네이티브 select() 루프는 실제 소켓뿐만 아니라 이 제어용 파이프를 동시에 감시합니다.

4.2. Instant Wake-up (Interrupt)
Java 단에서 tlsShutdown()이 호출되면 파이프에 즉각 시그널(1바이트)을 기록합니다.

select() 루프는 네트워크 패킷이 없더라도 시그널을 감지하여 즉각 깨어나며, S_SHUTDOWN 상태를 전파하여 점유 중인 모든 자원(SSL, CTX, Socket)을 해제하고 제어권을 Java로 즉시 반환합니다. 이는 ANR을 방지하는 결정적인 장치입니다.

5. 범용 보안 인터페이스 (Universal Tunneling)
본 모듈은 특정 서비스에 종속되지 않는 범용성을 지향합니다.

L4/L7 통합 추상화: TLSNativeIF는 Java 표준 InputStream/OutputStream을 상속받아 구현되어, 기존의 소켓 기반 코드를 그대로 수용합니다.

프로토콜 독립성: HTTP/1.1, HTTP/2는 물론, 커스텀 바이너리 프로토콜, 채팅, 파일 전송 등 TLS 보안이 필요한 모든 TCP 통신에 즉시 꽂아서(Plug-in) 사용할 수 있습니다.

6. 결론: 무정지 시스템을 위한 설계 (Stability Policy)
이중 뮤텍스 전략: 전역 관리를 위한 Oz.mutex와 개별 세션의 원자성을 보장하는 connlock을 분리하여 경합을 최소화합니다.

결정적 자원 회수: 세션 종료 시 모든 자원은 정해진 역순서에 따라 100% 해제됨을 보장하며, 단 1바이트의 메모리 누수도 허용하지 않습니다.
