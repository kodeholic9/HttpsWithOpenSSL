# HttpsWithOpenSSL

Android의 기본 네트워크 스택을 우회하고, JNI 계층에서 OpenSSL을 직접 연동하여 **OS 업데이트에 의존하지 않는 주도적인 보안 통제권**을 확보하기 위한 커스텀 HTTPS 클라이언트 라이브러리입니다.

## 🎯 기획 의도 및 핵심 가치
- **신속한 보안 대응 (Zero-Day 패치)**: 안드로이드 제조사의 OS 보안 패치 일정을 기다릴 필요가 없습니다. OpenSSL에 치명적인 취약점(CVE)이 발견될 경우, 앱 업데이트만으로 즉각적인 방어가 가능합니다.
- **파편화 없는 보안 환경**: OS 버전에 상관없이 구형 단말기에서도 최신 TLS 프로토콜 및 강력한 암호화 제품군(Cipher Suite)을 동일하고 일관되게 지원합니다.

## 🏗️ 아키텍처 (Architecture)
본 시스템은 3개의 계층으로 구성되어 유연성과 확장성을 보장합니다.
1. **Application Layer**: 비즈니스 로직 및 UI 처리
2. **Java Wrapper Layer (`TLSNativeIF` 등)**: HTTP 프로토콜 규격 조립, 기존 네트워크 API와의 호환성 제공 및 JNI 브릿지 역할
3. **Native Layer (`mytls_jni.cpp`, `OpenSSL`)**: 실제 소켓 통신, TLS 핸드셰이크, 패킷 암/복호화 수행

## ⚙️ 실무 운영 및 유지보수 전략
이 프로젝트의 강점을 극대화하기 위해 다음의 파이프라인과 전략을 고려하여 설계되었습니다.

1. **보안 라이브러리 교체 파이프라인**
   - 내장된 아키텍처별 정적 라이브러리(`libssl.a`, `libcrypto.a`)를 최신 버전으로 즉각 교체하고 JNI를 재빌드할 수 있는 구조를 취합니다. 
2. **장애 모니터링 및 롤백**
   - OpenSSL 버전 업그레이드 시 레거시 서버와의 핸드셰이크 실패 가능성에 대비합니다. JNI 계층의 세밀한 SSL 에러 코드를 Java로 전달하여 통신 장애를 조기 감지하고, 즉시 이전 브랜치로 롤백할 수 있는 체계를 운영합니다.
3. **바이너리 경량화 (APK 용량 최적화)**
   - OpenSSL 바이너리 포함으로 인한 앱 용량 증가를 최소화하기 위해, 서비스에서 사용하지 않는 구형 암호화 알고리즘(`no-idea`, `no-md2` 등)은 향후 컴파일 단계에서 제외하여 메모리 풋프린트를 최적화합니다.

## ⚠️ 개발 및 적용 시 주의사항 (Critical Checks)
- **메모리 누수 (Memory Leak)**: C/C++ 계층에서의 동적 할당과 OpenSSL 컨텍스트(`SSL_CTX`, `SSL` 객체)의 명시적 해제가 누락되면 안드로이드 OOM(Out of Memory)으로 직결됩니다. 연결 종료 시 철저한 자원 해제가 필수입니다.
- **성능 (JNI 오버헤드)**: Java와 Native를 오가는 컨텍스트 스위칭 비용이 발생합니다. 통신 버퍼 사이즈를 적절히 조절하여 JNI 경계를 넘나드는 횟수를 최소화해야 합니다.

## 📝 작성자
- author: kodeholic (powered by Gemini)
